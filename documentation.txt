Udemy Practical Typescript Course - John Smilga


Section 01: Introduction

01. Typescript Info


Section 02: Setup

02. Useful Info

03. Github Repository

04. Template
-otvorimo web stranicu https://vitejs.dev/
-otvorimo web stranicu https://www.typescriptlang.org/
-u terminalu ukucamo komandu npm create vite@latest 01-typescript-tutorial -- --template vanilla-ts

05. Files and Folders
-u demo u folder cd 01-typesript-tutorial folder
-u terminalu ukucamo komandu npm install
-kada instaliramo folder node_modules u terminalu ukucamo komandu npm run dev
-u folderu 01-typesript-tutorial kreiramo folder README.md za opis izrade projekta
-kreiramo tutorial.ts fajl
-u tutorial.ts fajl dodajemo komandu console.log()
-u main.ts fajl importujemo tutorial.ts fajl

06. Build Step
-u tutorial.ts fajlu kreiramo interface someValue i varijablu objekt let someObj
-u terminalu ukucamo komandu npm run build


Section 03: Typescript Fundamentals

07. Type Annotations
-u tutorial.ts fajlu kreiramo varijablu let awesomeName
-varijabli awesomeName dodajemo tip string
-deklarisemo varijablu awesomeName
-kreiramo varijablu let amount dodajemo tip amount
-kreiramo varijablu let isAwesome
-varijabli let isAwesome dodajemo tip boolean

08. Type Interface
-u tutorial.ts fajlu varijablama brisemo tipove

09. First Challenge
-u tutorial.ts fajlu kreiramo tri varijable let greeting, let age i let isAdult

10. Setup Info
-u tutorial.ts fajlu redeklarisemo varijable sa drugim tipom
-u terminalu ukucamo komandu npm run build

11. Union Type
-kreiramo varijablu let tax
-varijabli tax dodajemo tipove sa znakom | : number | string
-kreiramo varijablu let requestStatus
-varijabli let requestStatus dodajemo mogucu vrijednost, tip varijable sa znakom |

12. Type: Any
-u tutorial.ts fajlu kreiramo varijablu let notSure
-varijabli notSure dodajemo tip any
-redeklarisemo varijablu notSure sa drugim tipovima

13. Practical Example
-kreiramo varijablu niz const books
-kreiramo varijablu let foundBook sa tipovima string | undefined
-kreiramo petlju for (let book of books)
-u petlji for() dodajemo uslov if 
-redeklarisemo varijablu foundBook

14. Challenge - Union Type
-kreiramo varijablu let discount sa tipovima number | string
-kreiramo varijablu let orderStatus sa vise tipova Union |

15. Arrays
-u tutorial.ts fajlu kreiramo varijable nizove sa tipovima

16. Challenge - Arrays
-u tutorial.js fajlu kreiramo tri niz varijable let temperatures, let colors i let mixedArray sa tipovima

17. Object Fundamentals
-u tutorial.ts fajlu kreiramo objekt varijablu let car
-varijabli car dodajemo kljuc vrijednost brand i year
-varijabli let car dodajemo objekt tip
-kreiramo varijable let car1 i let car2
-kreiramo varijablu let items
-varijabli items dodajemo tip objekt i prazan niz []

18. Challenge - Objects
-u tutorial.ts fajlu kreiramo varijable objekte let bike, let laptop
-kreiramo varijable let product1, let product2 i niz let products koja sadrzi informacije o objektima

19. Functions - Parameters
-u tutorial.ts fajlu kreiramo funkciju sayHi()
-funkciji sayHi() dodajemo parametar name kao tip string
-u funkciju sayHi() dodajemo komandu console.log()

20. Functions - Returns
-kreiramo funkciju calculateDiscount()
-funkciji calculateDiscount() dodajemo parametar kao tip number
-funkciji calculateDiscount() dodajemo tip number
-dodajemo return izjavu 
-kreiramo varijablu const finalPrice
-kreiramo varijablu hasDiscount
-dodajemo uslov if (hasDiscount)

21. Type: Any Example
-u tutorial.ts fajlu kreiramo funkciju addThree()
-funkciji addThree() dodajemo parametar number sa tipom any
-u funkciji addThree() kreiramo varijablu let anotherNumber sa tipom number
-dodajemo return izjavu 
-kreiramo varijable const result i const someValue

22. Challenge - Functions 1
-u tutorial.ts fajlu kreiramo varijablu niz const names sa tipom string[]
-kreiramo funkciju isNameInList() sa parametrom name kao tipom string
-funkciji isNameInList() dodajemo tip boolean
-u funkciju isNameInList() dodajemo return izjavu 
-kreiramo varijablama let nameToCheck
-dodajemo uslov if (isNameInList(nameToCheck)) - else
-u uslove if - else dodajemo komande console.log()

23. Functions - Optional Parameters
-kreiramo funkciju calculatePrice() sa parametrima price i discount 
-parametrima dodajemo tipove number
-parametru discount dodajemo ? discount? u kojoj je parametar discount neobavezan
-funkciji calculatePrice() dodajemo tip number
-u funkciju calculatePrice() dodajemo return izjavu
-kreiramo varijablu let priceAfterDiscount

24. Functions - Default Parameters
-u tutorial.ts fajlu kreiramo varijablu let priceWithoutDiscount
-kreiramo funkciju calculateScore() sa parametar initialScore i penaltyPoints
-parametrima dodajemo tipove number
-tipu number dodajemo vrijednost 0
-funkciji calculateScore() dodajemo tip number
-u funkciju calculateScore() dodajemo return izjavu
-kreiramo varijable let scoreAfterPenalty i scoreWithoutPenalty

25. Functions - Rest Parameter
-u tutorial.ts fajlu kreiramo funkciju sum()
-kreiramo varijablu let result
-funkciji sum() dodajemo parametre message i ...numbers
-parametru message dodajemo tip string, parametru ...numbers dodajemo tip number[]
-funkciji sum() dodajemo tip string
-u funkciji sum() kreiramo varijablu const doubled 
-kreiramo varijablu let total

26. Functions - Void Keyword
-u tutorial.ts fajlu kreiramo funkciju logMessage() sa parametrom message
-parametru message dodajemo tip string
-u funkciju logMessage() dodajemo komandu console.log()
-pozivamo funkciju logMessage()
-funkciji logMessage() dodajemo tip void

27. Functions - Type Guards
-u tutorial.ts fajlu kreiramo funkciju processInput() sa parametrom input
-parametru input dodajemo tipove string | number
-otvorimo link: https://stackoverflow.com/questions/36560806/the-left-hand-side-of-an-arithmetic-operation-must-be-of-type-any-number-or
-u funkciju processInput() dodajemo uslove if (typeof input === 'number') - else
-pozivamo funkciju processInput() sa brojem i znakovnom vrijednosti

28. Functions - Objects As Parameters
-u tutorial.ts fajlu kreiramo funkciju createEmployee()
-funkciji createEmployee() dodajemo tip objekt sa vrijednostima id i isActive
-funkciji createEmployee() dodajemo parametar objekt id
-parametru objekt id dodajemo tip objekt id:number
-u funkciju createEmployee() dodajemo return izjavu u koju dodajemo objekt
-kreiramo varijable const first i const second
-kreiramo funkciju createStudent() sa parametrom student
-parametru student dodajemo tipove za objekt parametre id i name
-funkciji createStudent() dodajemo tip void
-u funkciju createStudent() dodajemo komandu console.log()
-kreiramo varijablu const newStudent
-pozivamo funkciju createStudent sa argumentom newStudent

29. Excess Property Check
-u tutorial.ts fajlu pozivamo fukciju createStudent() sa objektom koji ima jednu vise opciju nego sto je predvideno u parametru funkcije
-objektu newStudent dodajemo opciju email

30. Challenge - Functions II
-u tutorial.ts fajlu kreiramo funkciju processData sa dva parametrima
-prvom parametru input dodajemo tip string | number
-drugom parametru objektu config dodajemo tip boolean i default vrijednost
-dodajemo uslove if (typeof input === 'number') - else
-u uslov if dodajemo return izjavu u kojoj se mnozi parametar ako je broj
-u uslov else dodajemo return izjavu ako je parametar string i sadrzi opciju reverse true

31. Type Alias
-u tutorial.ts fajlu kreiramo tip type User
-kreiramo objekt varijable const john i const susan
-varijablama john i susan dodajemo tipove User
-kreiramo funkciju createUser() dodajemo parametar user
-parametru user dodajemo tip User
-funkciji createUser() dodajemo tip User
-u funkciju createUser() dodajemo komandu console.log()
-pozivamo funkcije createUser() sa argumentima john i susan

32. Type Alias - Additional Info
-u tutorial.ts fajlu kreiramo tip type StringOrNumber
-kreiramo varijablama let value
-varijabli let value dodajemo tip StringOrNumber
-deklarisemo varijablu value
-kreiramo tip type Theme
-kreiramo varijablu let theme
-varijabli let theme dodajemo tip Theme
-deklarisemo varijablu theme
-kreiramo funkciju setTheme() 
-funkciji setTheme() dodajemo parametar t
-parametru t dodajemo tip Theme
-pozivamo funkciju setTheme() sa argumentom

33. Challenge - Type Alias
-u tutorial.ts fajlu kreiramo tipove type Employee i type Manager
-kreiramo varijable const alice, const steve i const bob
-varijablama dodajemo tipove Employee i Manager
-kreiramo tip type Staff koji sadrzi tipove Employee i Manager
-kreiramo funkciju printStaffDetails() sa parametrom staff koji ima tip Staff
-funkciji printStaffDetails() dodajemo tip void
-u funkciju printStaffDetails() dodajemo uslove if ('employees' in staff) - else
-u uslove if i else dodajemo komande console.log()
-pozivamo funkcije printStaffDetails() sa argumentima alice, steve i bob

34. Intersection Type
-u tutorial.ts fajlu kreiramo tip type Book
-kreiramo objekt varijablama const book1 i const book2
-kreiranim varijablama dodajemo tip Book
-kreiramo tip type DiscountedBook koji sadrzi tip Book i opciju discount kombinovan sa znakom &
-kreiramo varijablu const discountedBook koja ima tip DiscountedBook

35. Computed Properties
-u tutorial.ts fajlu kreiramo varijablu let tiger
-kreiramo varijablu const propName
-kreiramo tip type Animal
-varijabli tiger dodajemo tip Animal
-u tip Animal dodana varijabla [propName] sa tipom number

36. Interface - Fundamentals
-u tutorial.ts fajlu kreiramo interfejs interface Book
-u interfejs Book dodajemo opcije readonly isbn, title, author i genre?
-kreiramo varijablu const deepWork sa tipom Book

37. Interface - Methods
-u tutorial.ts fajlu, u interfejs Book dodajemo metode printAuthor() i printTitle() 
-metodi printAuthor() dodajemo tip void
-metodi printTitle() dodajemo parametar message sa tipom string
-metodi printTitle() dodajemo tip string
-u objekt varijablu deepWork dodajemo metode printAuthor() i printTitle()
-pozivamo metodu deepWork.printAuthor()
-pozivamo metodu deepWork.printTitle()
-metodu deepWork.printTitle() pohranjujemo u varijablu const result

38. Interface Methods - More Options
-u tutorial.ts fajlu, u interfejs Book dodajemo metodu printSomething()

39. Challenge - Interface I
-u tutorial.ts fajlu kreiramo interfejs Computer
-u interfejs dodajemo tipove za varijable id, brand, ram, storage i metodu upgradeRam()
-kreiramo varijablu const laptop koja ima tip Computer
-dodajemo metodu laptop.storage
-dodajemo metodu laptop.upgradeRam()

40. Interface - Merge and Extend
-kreiramo interfejs Person
-u interfejsu Person dodajemo tipove za varijable name, age i metodu getDetails()
-kreiramo interfejs DogOwner
-u interfejsu DogOwner dodajemo tipove za varijablu dogName i metodu getDogDetails()
-kreiramo varijablu const person sa tipom Person
-dodajemo metodu person.getDetails()
-kreiramo interfejs Employee
-interfejsu Employee dodajemo metodu extends Person
-u interfejs Employee dodajemo tip za varijablu employeeId
-kreiramo varijablu const employee sa tipom Employee
-kreiramo interfejs Manager extends Person, DogOwner
-kreiramo varijablu const manager sa tipom Manager
-u interfejs Manager dodajemo metodu managePeople() sa tipom
-u varijablu manager dodajemo metodu managePeople()
-dodajemo metode manager.getDetails(), manager.getDogDetails() i managePeople.managePeople()

41. Challenge - Interface II
-u tutorial.ts fajlu kreiramo interfejse Person i DogOwner
-kreiramo interfejs Manager koji sadrzi interfejs Person
-kreiramo funkciju getEmployee() sa tipovima Person, DogOwner i Manager
-kreiramo varijablu const random
-dodajemo uslove if, else if i else
-kreiramo varijablu const employee sa tipovima Person, DogOwner i Manager
-dodajemo uslov if ('managePeople' in employee)

42. Interface - Type Predicate
-u tutorial.ts fajlu kreiramo funkciju isManager()
-funkciji isManager() dodajemo parametar obj sa tipovima Person, DogOwner i Manager
-funkciji isManager() dodajemo tip obj is Manager
-dodajemo uslov if (isManager(employee))
-u uslov if dodajemo metodu employee.delegateTasks()

43. Interface vs Type Alias

44. Tuple
-u tutorial.ts fajlu kreiramo varijablu let person sa tipovima [string, number]
-kreiramo varijablu let date sa tipovima readonly [number, number, number]
-kreiramo funkciju getPerson() sa tipovima [string, number]
-kreiramo varijablu let randomPerson
-kreiramo varijablu let susan koja ima tip readonly [string, number]

45. Enum - Fundamentals
-u tutorial.ts fajlu kreiramo enum ServerResponseStatus
-kreiramo interfejs ServerResponse
-kreiramo funkciju getServerResponse() sa tipom ServerResponse
-kreiramo varijablu const response sa tipom ServerResponse

46. Enum - Reverse Mapping
-u tutorial.ts fajl dodajemo metodu Object.values()
-u metodu Object.values() dodajemo uslov if
-u tutorial.ts fajlu kreiramo enumi NumericEnum i StringEnum
-kreiramo varijablu let numericEnumValue sa tipom NumericEnum
-kreiramo varijablu let stringEnumValue sa tipom StringEnum

47. Challenge - Tuple and Enum
-u tutorial.ts fajlu kreiramo enum UserRole i tip User
-kreiramo funkciju createUser() sa parametrom user koji ima tip User
-funkciji User dodajemo tip User
-kreiramo varijablu const user sa tipom User

48. Type Assertion
-kreiramo varijablu let someValue sa tipom any
-dodajemo metodu (someValue as string).length
-vrijednost metode (someValue as string).length pohranjujemo u varijablu let strLength koja ima tip number
-kreiramo tip Bird
-kreiramo varijable let birdString i dogString
-kreiramo varijable let birdObject i let let dogObject
-kreiramo varijable let bird i let dog
-kreiramo enum Status i tip User
-kreiramo varijablu const statusValue
-kreiramo varijablu const user sa tipom User

49. Type - Unknown
-kreiramo varijablu let unknownValue sa tipom unknown
-redeklarisemo varijablu let unknownValue vise puta
-dodajemo uslov if da provjerimo tip varijable
-kreiramo funkciju function runSomeCode()
-u funkciji runSomeCode() kreiramo varijablu const random
-dodajemo uslov if (random < 0.5) - else
-kreiramo blokove koda try - catch
-u blok koda try dodajemo funkciju runSomeCode()
-u blok koda catch dodajemo uslov if (error instanceof Error) - else

50. Type - never
-kreiramo varijablu let someValue
-kreiramo tip Theme
-kreiramo funkciju checkTheme() sa parametrom theme koji ima tip Theme
-funkciji checkTheme() dodajemo tip void
-u fukciju checkTheme() dodajemo uslove if u kojima provjeravamo da li je varijabla jednaka vrijednosti dark ili theme
-kreiramo enum Color
-kreiramo funkciju getColorName() sa parametrom color koji ima tip Color
-u funkciju getColorName() dodajemo uslov switch (color)
-u uslov switch (color) dodajemo slucajeve za Color.Red i Color.Blue
-dodajemo slucaj default
-u slucaju default kreiramo varijablu let unexprectedColor sa tipom never
-dodajemo throw new Error()
-pozivamo funkcije sa tri razlicite boje

51. Modules - Intro
-u tutorial.ts fajlu kreiramo varijable let name i let susan
-kreiramo i eksportujemo varijablu let something
-kreiramo actions.ts fajl
-u actions.ts fajlu kreiramo varijablu const susan
-kreiramo i eksportujemo varijablu const something

52. Modules - ES6
-u actions.ts fajlu kreiramo i eksportujemo funkciju sayHello() sa parametrom name koji ima tip string
-funkciji sayHello() dodajemo tip void
-u funkciju sayHello() dodajemo komandu console.log()
-kreiramo i eksportujemo varijablu let person
-kreiramo i eksportujemo tip Student
-kreiramo varijablu const newStudent koja ima tip Student
-varijablu newStudent eksportujemo kao default
-u tutorial.ts fajl importujemo varijable newStudent, person, funkciju sayHello i tip Student iz actions.ts fajla
-pozivamo funkciju sayHello() sa stringom
-kreiramo varijablu const anotherStudent koja ima tip Student

53. Modules - JS File
-kreiramo example.ts fajl 
-u example.ts fajlu kreiramo i eksportujemo varijablu let someValue
-u tutorial.ts fajl importujemo varijablu someValue

54. Type Guards - Typeof
-u tutorial.ts fajlu kreiramo tip ValueType
-kreiramo varijablu let value sa tipom ValueType
-kreiramo varijablu const random
-redeklarisemo varijablu value
-kreiramo funkciju checkValue() sa parametrom value koji ima tip ValueType
-funkciji checkValue() dodajemo tip void
-u funkciju checkValue() dodajemo uslove if u kojima provjeravamo tipove varijabli
-pozivamo funkciju checkValue()

55. Type Guards - Equality and "in"
-u tutorial.ts fajlu kreiramo tipove Dog, Cat i Animal
-kreiramo funkciju makeSound() sa parametrom animal koji ima tip Animal
-u funkciju makeSound() dodajemo uslov if - else da provjerimo tip zivotinje
-u uslov if dodajemo ===
-kreiramo funkciju makeSound2() sa parametrom animal koji ima tip Animal
-u funkciju makeSound2() dodajemo uslov if - else da provjerimo tip zivotinje
-u uslov if dodajemo da li se string bark nalazi u varijabli animal
-kreiramo varijable const dog i const cat
-pozivamo funkcije makeSound() i makeSound2()

56. Type Guards - Truthy and Falsy
-u tutorial.ts fajlu kreiramo funkciju printLength() sa parametrom str koji ima tipove string, null i undefined
-u funkciju printLength() dodajemo uslovi if (str) - else da provjerimo da li je vrijednost truthy ili falsy
-pozivamo funkciju printLength() sa razlicitim vrijednostima

57. Type Guards - Instanceof
-u tutorial.ts fajlu kreiramo blokove koda try - catch za Error poruku
-kreiramo funkciju checkInput() sa parametrom input koji ima tipove Date i string
-funkciji checkInput() dodajemo tip string
-u funkciju checkInput() dodajemo uslov if (input instanceof Date)
-kreiramo varijable const year i const random

58. Type Guards - Type Predicate
-kreiramo tip Student sa varijablom name kao string i metodom study kao void
-kreiramo tip User sa varijablom name kao string i metodom login kao void
-kreiramo tip Person koji sadrzi tipove Student i User
-kreiramo funkciju randomPerson() koja ima tip Person
-kreiramo varijablu const person
-kreiramo funkciju function isStudent() sa parametrom person koji ima tip Person
-fukciji isStudent() dodajemo metodu person is Student
-u return izjavu dodajemo metodu (person as Student)
-dodajemo uslov if (isStudent(person)) - else

59. Type "never" Gotcha
-u tutorial.ts fajlu kreiramo varijablu const person sa tipom Person

60. Type Guards - Discriminated Unions
-u tutorial.ts fajlu kreiramo tipove IncrementAction i DecrementAction
-kreiramo tip Action koji sadrzi tipove IncrementAction i DecrementAction
-kreiramo funkciju reducer() sa parametrima state i action
-prvi parametar state ima tip number
-drugi parametar action ima tip Action
-kreiramo varijablu const newState
-u funkciju reducer() dodajemo uslov switch (action.type)
-u uslov switch() dodajemo slucajeve increment i decrement
-dodajemo slucaj default
-u slucaju default kreiramo varijablu const unexpectedAction sa tipom never
-dodajemo metodu throw new Error()

61. Generics - Intro
-u tutorial.ts fajlu kreiramo varijable nizove let array1, let array2 i let array3
-nizovima dodajemo tip Array<>
-u <> dodajemo tip niza: string, number boolean

62. Generics - First Function and Interface
-u tutorial.ts fajlu kreiramo funkciju genericFunction<T>() sa parametrom arg
-funkciji genericFunction() i parametru dodajemo tip T
-kreiramo varijable const someStringValue i someNumberValue
-kreiramo interfejs GenericInterface<T>
-kreiramo varijablu const genericString sa tipom GenericInterface<string>

63. Generics - Promise Example
-kreiramo funkciju someFunc() sa tipom Promise<string>
-kreiramo varijablu const result

64. Generics - Create Array
-u tutorial.ts fajlu kreiramo funkciju generateStringArray() sa dva parametra length i value
-parametrima i funkciji generateStringArray() dodajemo tipove
-u funkciji generateStringArray() kreiramo varijablu let result sa tipom string[]
-redeklarisemo varijablu result
-kreiramo funkciju createArray<T>() sa parametrime length i value
-prvom parametru length dodajemo tip number
-drugom parametru value dodajemo tip T
-funkciji createArray<T>() dodajemo tip Array<T>
-kreiramo varijablu let result sa tipom T[]
-redeklarisemo varijablu result
-kreiramo varijable let arrayStrings i let arrayNumbers

65. Generics - Multiple Types
-u tutorial.ts fajlu kreiramo funkciju pair<T, U>() sa prametrima param1 i param2
-prvom parametru param1 dodajemo tip T
-drugom parametru param2 dodajemo tip U
-funkciji pair() dodajemo tip [T, U]
-kreiramo varijablu let result

66. Generics - Type Constraints
-u tutorial.ts fajlu kreiramo funkciju processValue<T extends string>() sa parametrom value
-parametru value i funkciji processValue() dodajemo tipove T
-pozivamo funkciju sa argumentima vise puta

67. Generics - Type Constraints Second Example
-kreiramo vise tipova i varijabli kojima dodajemo tipove
-kreiramo funkciju printName<T extends Student> sa parametrom input koji ima tip T
-funkciji printName() dodajemo tip void
-pozivamo funkciju printName() vise puta sa argumentima

68. Generics - Default Type
-u tutorial.ts fajlu kreiramo interfejs StoreData<T>
-kreiramo varijablu const storeNumbers sa tipom StoreData<number>
-kreiramo varijablu const randomStuff sa tipom StoreData

69. Fetch Data - Basics
-kreiramo varijablu const url
-kreiramo asinhronu funkciju fetchData() sa parametrom url koji ima tip string
-u funkciji fetchData() kreiramo blokove koda try - catch
-u bloku koda try kreiramo varijablu const response
-dodajemo uslov if(!response.ok)
-u uslov if dodajemo throw new Error()
-kreiramo varijablu const data
-dodajemo izjavu return data
-u bloku koda catch kreiramo varijablu const errorMsg
-pozivamo funkciju fetchData() sa argumentom
-vrijednost funkcije await fetchData() pohranjujemo u varijablu const tours
-dodajemo metodu tours.map() sa parametrom tour
-parametru tour dodajemo tip any

70. Fetch Data - Setup Type
-u tutorial.ts fajlu kreiramo tip Tour sa vrijednostima id, name, info, image i price
-vrijednostima dodajemo tipove
-funkciji fetchData() dodajemo tip Promise<Tour[]>
-varijabli const data dodajemo tip Tour[]
-parametru tour u metodi map() brisemo tip any

71. Fetch Data - Gotcha
-u tutorial.ts fajlu, u tip Tour dodajemo vrijednost something 

72. Zod Library
-otvorimo web stranicu https://zod.dev/
-u terminalu instaliramo paket Zod sa komandom npm i zod
-u tutorial.ts fajl importujemo instancu z iz paketa zod
-kreiramo metodu z.object({ ... })
-u objektu dodajemo tipove za varijable
-dodajemo metodu z.infer<>
-vrijednost metode z.infer<> pohranjujemo u tip Tour
-u funkciji fetchData() preimenujemo varijablu const data u rawData
-kreiramo varijablu const result
-dodajemo uslov if (!result.success)
-dodajemo izjevu return result.data

73. Declaration Files
-kreiramo types.ts fajl 
-u types.ts fajlu kreiramo i eksportujemo tip Random

74. TS Config
-u tutorial.ts fajlu kreiramo varijablu let something

75. Classes - Intro
-u tutorial.ts fajlu kreiramo klasu class Book
-u klasi Book kreiramo funkciju constructor() sa dva parametra title i author
-parametrima dodajemo tipove string
-dodajemo metode this.title i this.author
-varijablama title i author dodajemo tipove string
-pozivamo metodu new Book() sa dva argumenta
-vrijednost metode new Book() pohranjujemo u varijablu const deepWork

76. Classes - Default Property
-u tutorial.ts fajlu dodajemo varijablu checkedOut sa tipom boolean
-varijabli deepWork dodajemo metodu checkedOut

77. Classes - Readonly Modifier
-u tutorial.ts fajlu, u klasi Book dodajemo varijabli title opciju readonly

78. Classes - Public and Private Modifiers
-u tutorial.ts fajlu, u klasi Book varijablama title i author dodajemo opciju public
-varijabli checkedOut dodajemo opciju private
-kreiramo public metode checkOut() i isCheckedOut()
-kreiramo private metodu toggleCheckedOutStatus()

79. Classes - Constructor Shortcut
-u tutorial.ts fajlu, u klasi Book, funkciji constructor() dodajemo parametrima tipove
-kreiramo metodu getSomeValue()

80. Classes - Getters and Setters
-u tutorial.ts fajlu, u klasi Book kreiramo metodu get info()
-kreiramo metodu set checkOut() sa parametrom checkedOut koji ima tip boolean
-kreiramo metodu get checkOut()
-kreiramo metodu public get someInfo()

81. Classes - Implement Interface
-u tutorial.ts fajlu kreiramo interfejs IPerson
-kreiramo klasu Person implements IPerson
-u klasi Person kreiramo funkciju constructor() sa parametrima name i age
-parametrima dodajemo tipove string i number
-kreiramo metodu greet() sa tipom void
-pozivamo metodu new Person() sa dva argumenta
-vrijednost metode new Person() pohranjujemo u varijablu const hipster
-varijabli hipster dodajemo metodu greet()

82. Tasks Project - Setup
-kreiramo tasks.html fajl i HTML struktura
-u main.ts fajl dodajemo HTML element <a> za navigaciju na Tasks App
-kreiramo fajlove tasks.ts i tasks.css 
-u tasks.css fajl dodajemo CSS stil

83. Tasks Project - Useful Info
-u tasks.ts fajlu kreiramo varijablu const btn
-varijabli btn dodajemo metodu document.querySelector()
-varijabla btn dodajemo metodu addEventListener()

84. Tasks Project - Select Elements
-u tasks.ts fajlu kreiramo tri varijable: const taskForm, const formInput i const taskListElement
-u metodu querySelector() dodajemo opciju <HTMLFormElement>
-kreiramo tip Task
-kreiramo varijablu const tasks sa tipom Task[]

85. Tasks Project - Submit Event
-varijabli taskForm dodajemo funkciju addEventListener()
-prvi argument funkcije addEventListener je dogadaj submit
-drugi argument je anonimna funkcija sa parametrom event
-u anonimnu funkciju dodajemo metodu event.preventDefault()
-kreiramo varijablu const taskDescription
-dodajemo uslov if (taskDescription)
-u uslov if dodajemo formInput.value

86. Tasks Project - Event Gotcha
-kreiramo funkciju createTask() sa parametrom event
-parametru event dodajemo tip SubmitEvent
-u funkciju addEventListener() proslijedujemo funkciju createTask() kao drugi argument

87. Tasks Project - Add Task
-kreiramo funkciju addTask() sa parametrom task koji ima tip Task
-funkciji addTask() dodajemo tip void
-u funkciju addTask() dodajemo metodu tasks.push(task)
-u uslovu if (taskDescription) kreiramo varijablu const task koja ima tip Task
-pozivamo funkciju addTask(task)

88. Tasks Project - Render Task
-kreiramo funkciju renderTask() sa parametrom task koji ima tip Task
-funkciji renderTask() dodajemo tip void
-u funkciji renderTask() kreiramo varijablu const taskElement
-varijabli taskElement dodajemo metodu textContent
-varijabli taskListElement dodajemo metodu appendChild(taskElement)
-u funkciju addEventListener() dodajemo funkciju renderTask(task)

89. Tasks Project - Local Storage
-kreiramo funkciju updateStorage() koja ima tip void
-u funkciju updateStorage() dodajemo metodu localStorage.setItem()
-u funkciju addEventListener() dodajemo funkciju updateStorage()
-kreiramo funkciju loadTasks() koja ima tip Task[]
-u funkciji loadTasks() kreiramo varijablu const storedTasks
-dodajemo return izjavu gdje provjeravamo da li imamo taskove
-vrijednost funkcije loadTasks() pohranjujemo u varijablu const tasks
-dodajemo metodu tasks.forEach(renderTask)

90. Tasks Project - Checkbox
-u funkciji renderTask() kreiramo varijabla const taskCheckbox
-varijabli taskCheckbox dodajemo metode type i checked
-varijabli taskElement dodajemo metodu appendChild(taskCheckbox)
-varijabli taskCheckbox dodajemo funkciju addEventListener()
-funkciji addEventListener() dodajemo dva argumenta
-prvi argument je dogadaj change
-drugi argument je anonimna funkcija
-u anonimnu funkciju dodajemo metodu task.isCompleted
-dodajemo funkciju updateStorage()


Section 04: Typescript and React

91. Setup
-u terminalu instaliramo Vite React.js aplikaciju sa komandom npm create vite@latest

92. Files and Folders
-u README.md fajl dodajemo uputstvo za izradu projekta
-u folderu src kreiramo folder starter
-u index.css fajl dodajemo CSS stil
-obrisemo App.css fajl

93. Component Return
-u folderu 01-return, u index.tsx fajlu, funkciji Component() dodajemo tip JSX.Element
-u komponentu App.jsx importujemo komponentu Component

94. Props - Inline
-u folderu 02-props, u index.tsx fajlu, funkciji Component() dodajemo parametre destruktuirane prop name i id
-parametrima name i id dodajemo tipove

95. Props - Type Alias / Interface
-u folderu 02-props, u index.tsx fajlu, kreiramo tip ComponentProps
-u funkciji Component(), parametrima name i id dodajemo tip ComponentProps

96. Children Prop
-u folderu 02-props, u index.tsx fajlu, u tip ComponentProps dodajemo prop children? koji ima tip React.ReactNode
-u App.tsx komponenti dodajemo komponentu Component sa otvorenim i zatvorenim tagom
-importujemo prop tip PropsWithChildren
-kreiramo prop PropsWithChildren<>
-vrijednost prop PropsWithChildren pohranjujemo u tip ComponentProps

97. State
-u folderu 03-state, u index.tsx fajl, importujemo i kreiramo fukciju useState()
-kreiramo state varijable text, number i list
-kreiramo set funkcije setText, setNumber i setList
-u jsx-u kreiramo button element sa prop className i dogadajem onClick
-u dogadaj onClick proslijedujemo set funkcije

98. State - Custom List
-u folderu 03-state, u index.tsx fajl, kreiramo varijablu const navLinks
-kreiramo tip Link
-varijabli navLinks dodajemo tip Link[]
-kreiramo state varijablu links i set funkciju setLinks
-u dogadaj onClick proslijedujemo funkciju setLinks()
-funkciji() useState dodajemo tip <Link[]>

99. Events - Change Event
-u folderu 04-events, u index.tsx fajl, importujemo funkciju useState
-kreiramo state varijable text i email
-kreiramo set funkcije setText i setEmail
-u jsx-u kreiramo form i input HTML elemente
-input elementima dodajemo prop type, className, value i onChange
-kreiramo funkciju handleChange() sa parametrom e
-u input elementu za email, u dogadaj onChange proslijedujemo funkciju handleChange
-parametru e dodajemo tip React.ChangeEvent<HTMLInputElement>

100. Events - Form Event
-u folderu 04-events, u index.tsx fajlu, kreiramo funkciju handleSubmit() sa parametrom e
-parametru e dodajemo tip React.FormEvent<HTMLFormElement>
-form elementu dodajemo dogadaj onSubmit
-u dogadaj onSubmit proslijedujemo funkciju handleSubmit
-u funkciju handleSubmit() dodajemo e.preventDefault()
-kreiramo varijablu const formData
-kreiramo varijablu const data
-kreiramo tip Person
-kreiramo varijablu const person koja ima tip Person
-kreiramo varijablu const text

101. Challenge - Intro
-u komponentu App.tsx importujemo komponentu Component iz foldera 05-challenge

102. Challenge - First Solution
-u 05-challenge, index.tsx fajlu kreiramo tip ProfileCardProps
-funkciji Component() dodajemo parametar props sa tipom ProfileCardProps
-destruktuiramo varijable const { type, name, email } iz parametra props
-kreiramo varijablu const alertType
-kreiramo varijablu const className
-u jsx-u kreiramo HTML element article sa prop className
-u prop className proslijedujemo vrijednost varijable className
-dodajemo uslov {email && ...}

103. Challenge - Alternative Solution
-u komponenti App.tsx, komponenti Component dodajemo prop email

104. Challenge - Typescript Solution
-u 05-challenge, index.tsx fajlu kreiramo tipove BasicProfileCardProps, AdvancedProfileCardProps i AdvancedProfileCardProps
-destruktuiramo varijable const { type, name } iz parametra props
-dodajemo uslov if (type === 'basic')
-u uslov if dodajemo return izjavi
-u return izjavi kreiramo HTML element article sa klasama alert i alert-success
-u jsx-u kreiramo HTML element article sa klasama alert i alert-danger
-u komponenti App.jsx uklonimo jednoj komponenti Component prop email

105. Context API - Basic Example
-u App.tsx komponentu importujemo komponentu Component iz foldera 06-context
-u folderu 06-context kreiramo context.tsx fajl
-u context.tsx fajl importujemo funkcije createContext, useContext u useState iz paketa react
-kreiramo funkciju createContext<string | undefined>
-vrijednost funkcije createContext() pohranjujemo u varijablu const ThemeProviderContext
kreiramo i eksportujemo funkciju ThemeProvider() sa destruktuiranim parametrom children
-parametru children dodajemo tip React.ReactNode
-u return izjavi kreiramo komponentu ThemeProviderContext.Provider sa otvorenim i zatvorenim tagom
-komponenti ThemeProviderContext.Provider dodajemo prop value
-u komponentu ThemeProviderContext.Provider dodajemo prop children
-kreiramo i eksportujemo funkciju useTheme
-u funkciji useTheme() kreiramo varijablu const context
-dodajemo uslov if (context === undefined)
-u uslov if dodajemo throw new Error()
-u index.tsx fajl importujemo funkciju useTheme i komponentu ThemeProvider
-kreiramo funkciju ParentComponent()
-u funkciju ParentComponent() dodajemo komponentu ThemeProvider sa otvorenim i zatvorenim tagom
-u komponentu ThemeProvider dodajemo komponentu Component

106. Context API - Theme Example
-u context.tsx fajlu kreiramo tip Type
-kreiramo state varijablu theme i set funkciju setTheme
-u prop value proslijedujemo varijablu theme i funkciju setTheme
-kreiramo tip ThemeProviderState
-funkciji createContext() dodajemo tip ThemeProviderState
-kreiramo tip ThemeProviderProps
-u funkciji ThemeProvider(), parametrima children i defaultTheme dodajemo tip ThemeProviderProps
-u index.tsx fajlu kreiramo button element
-button elementu dodajemo dogadaj onClick
-u dogadaj onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju dodajemo uslov if kojim provjeravamo da li tamna tema
-u uslov if dodajemo metodu context.setTheme()

107. useReducer - Setup
-u komponentu App.tsx importujemo komponentu Component iz foldera 07-reducers
-u folderu 07-reducers, u index.tsx fajl importujemo i kreiramo funkciju useReducer()
-vrijednost funkcije useReducer() pohranjujemo u varijablu state i funkciju dispatch 
-u jsx-u kreiramo div i button elemente
-kreiramo reducer.ts fajl
-u reducer.ts fajlu kreiramo i eksportujemo tip CounterState
-kreiramo i eksportujemo varijablu const initialState
-varijabli initialState dodajemo tip CounterState
-kreiramo i eksportujemo funkciju counterReducer() sa dva parametra state i action
-u index.tsx fajl importujemo varijablu initialState i funkciju counterReducer

108. useReducer - Counter
-u reducer.ts fajlu kreiramo tipove UpdateCountAction i CounterAction
-u funkciji counterReducer(), parametru action dodajemo tip CounterAction
-u funkciju counterReducer() dodajemo uslov switch(action.type)
-u uslov switch() dodajemo slucajeve increment, decrement i reset
-u index.tsx fajlu, button elementima dodajemo dogadaje onClick
-u dogadaje onClick proslijedujemo funkcije dispatch()

109. useReducer - Status
-u reducer.ts fajlu kreiramo tip SetStatusAction
-u uslov switch() dodajemo slucaj setStatus
-u index.tsx fajlu, button elementima dodajemo dogadaj onClick
-u dogadaj onClick proslijedujemo funkcije dispatch za status aktivnosti

110. Fetch Data - UseEffect and Fetch API
-u komponentu App.tsx importujemo komponentu Component iz foldera 08-fetch-data
-u 08-fetch-data folderu, u index.tsx fajl importujemo funkcije useState i useEffect
-kreiramo varijablu const url
-kreiramo funkcije useState sa tipovima <>
-u funkciji Component() kreiramo state varijable isLoading i isError
-kreiramo state varijable setIsLoading i setIsError
-kreiramo funkciju useEffect() sa dva argumenta
-prvi argument je anonimna funkcija, a drugi argument prazan niz []
-u anonimnoj funkciji kreiramo asinhronu funkciju fetchData()
-u funkciju fetchData() dodajemo funkciju setIsLoading(true)
-u funkciji fetchData() kreiramo blokove koda try, catch i finally
-u bloku koda try kreiramo varijablu const response
-dodajemo uslov if (!response.ok)
-u uslov if dodajemo throw new Error()
-u bloku koda catch kreiramo varijablu const message
-dodajemo funkciju setIsError(message)
-u blok koda finally dodajemo funkciju setIsLoading(false)
-dodajemo uslove if (isLoading) i if (isError)

111. Fetch Data - Type and Schema
-u folderu 08-fetch-data kreiramo types.ts fajl
-u types.ts fajl importujemo instancu z iz paketa zod
-kreiramo i eksportujemo varijablu const tourSchema
-kreiramo i eksportujemo tip Tour
-u index.tsx fajl importujemo tip Tour i varijablu tourSchema iz types.ts fajla
-funkciji useState za ture dodajemo tip <Tour[]>
-varijablu rawData dodajemo tip Tour[]
-kreiramo varijablu const result
-dodajemo uslov if (!response.success)
-u uslov if dodajemo throw new Error()
-dodajemo funkciju setTours(result.data)
-jsx dodajemo metodu tours.map()

112. Fetch Data - React Query and Axios
-u terminalu instaliramo pakete Axios i React Query
-u types.ts fajl importujemo instancu axios
-premjestamo varijablu const url iz index.tsx fajla u types.ts fajl
-kreiramo i eksportujemo asinhronu funkciju fetchTours() 
-funkciji fetchTours() dodajemo tip Promise<Tour[]>
-kreiramo varijablu const response
-u funkciji fetchTours() kreiramo varijable const response i const result
-dodajemo uslov if (!result.success)
-dodajemo return izjavu result.data
-u main.tsx importujemo komponente QueryClient i QueryClientProvider iz paketa tanstack/react-query
-kreiramo varijablu const queryClient
-u funkciji render() kreiramo komponentu QueryClientProvider sa otvorenim i zatvorenim tagom
-komponenti QueryClientProvider dodajemo prop client
-u prop client proslijedujemo varijablu queryClient
-u index.tsx fajl importujemo funkciju fetchTours
-importujemo i kreiramo funkciju useQuery()
-u funkciju useQuery() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo opcije queryKey i queryFn
-vrijednost funkcije useQuery() pohranjujemo u destruktuirane varijable const { isPending, isError, error, data:tours }
-dodajemo uslove if (isPending) i if (isError) 

113. RTK - Slice
-u komponentu App.tsx importujemo komponentu Component iz foldera 09-rtk
-u terminalu instaliramo pakete React Redux i Redux Toolkit
-u folderu 09-rtk kreiramo counterSlice.ts fajl
-u counterSlice.ts fajl importujemo i kreiramo funkciju createSlice iz paketa Redux Toolkit 
-importujemo tip PayloadAction iz paketa Redux Toolkit
-vrijednost funkcije createSlice pohranjujemo u varijablu const counterSlice
-eksportujemo varijablu const counterSlice
-eksportujemo kao default varijablu counterSlice.reducer
-kreiramo objekt varijablu const initialState
-u funkciju createSlice dodajemo opcije name, initialState i reducers
-kreiramo tip CounterState
-u tipu CounterState dodajemo varijable count i status
-kreiramo tip CounterStatus
-varijabli initialState dodajemo tip CounterState
-u objektu reducers kreiramo cetiri funkcije: increment(), decrement(), reset() i setStatus()
-funkcijama increment, decrement i reset dodajemo parametar state
-funkciji setStatus() dodajemo parametre status i action
-parametru action dodajemo tip PayloadAction<CounterStatus>
-eksportujemo funkcije kao counterSlice.actions

114. RTK - Setup
-kreiramo store.ts fajl
-u store.ts fajl importujemo i kreiramo funkciju configureStore iz paketa Redux Toolkit
-importujemo funkciju counterReducer iz counterSlice.ts fajla
-vrijednost funkcije configureStore() pohranjujemo u varijablu const store
-eksportujemo varijablu store
-kreiramo i eksportujemo tipove RootState i AppDispatch
-kreiramo hooks.ts fajl
-u hooks.ts fajl importujemo funkcije useDispatch i useSelector
-importujemo tip TypedUseSelectorHook iz paketa React Redux
-importujemo tipove RootState i AppDispatch iz store.ts fajla
-kreiramo i eksportujemo funkciju useAppDispatch 
-kreiramo i eksportujemo varijablu const useAppSelector
-u main.jsx fajl importujemo varijablu store iz store.ts fajla
-importujemo komponentu Provider iz paketa React Redux
-u funkciji render kreiramo komponentu Provider sa otvorenim i zatvorenim tagom
-komponenti Provider dodajemo prop store
-u prop store proslijedujemo varijablu store

115. RTK - Complete
-u index.tsx fajl importujemo i kreiramofunkcije useAppSelector i useAppDispatch
-importujemo funkcije iz counterSlice.ts fajla
-vrijednost funkcije useAppSelector() pohranjujemo u destruktuirane varijable const { count, status }
-vrijednost funkcije useAppDispatch() pohranjujemo u varijablu const dispatch
-u jsx-u, button elementima dodajemo dodajemo dogadaje onClick
-u dogadaje onClick proslijedujemo funkcije dispatch()
-u funkcije dispatch() proslijedujemo importovane funkcije iz counterSlice.ts fajla

116. Tasks Project - Setup
-u komponentu App.tsx importujemo komponentu Component iz foldera 10-tasks
-kreiramo types.ts fajl 
-u types.ts fajlu kreiramo i eksportujemo tip Task
-kreiramo komponente Form.tsx i List.tsx
-u index.tsx fajl importujemo funkcije useState i useEffect
-importujemo komponente Form.tsx i List.tsx
-kreiramo state varijablu const tasks i set funkciju setTasks()
-funkciji useState() dodajemo tip <Task[]>

117. Tasks Project - Form Setup
-u komponentu Form.tsx importujemo funkciju useState
-importujemo tip Task
-kreiramo state varijablu const task i set funkciju setTask()
-u jsx-kreiramo HTML elemente form, input i button
-form elementu dodajemo klase form i task-form
-input elementu dodajemo prop type, className, value i dogadaj onChange
-u dogadaj onChange proslijedujemo anonimnu fukciju sa parametrom e
-u anonimnu funkciju proslijedujemo funkciju setText()
-button elementu dodajemo prop type i className
-kreiramo funkciju handleSubmit() sa parametrom e
-parametru e dodajemo tip React.FormEvent<HTMLFormElement>
-u funkciju handleSubmit() dodajemo metodu e.preventDefault()
-dodajemo uslov if (!test)
-nakon uslova if dodajemo funkciju setText('')

118. Tasks Project - Add Task
-u index.tsx fajlu kreiramo funkciju addTask() sa parametrom task koji ima tip Task
-fukciji addTask() dodajemo tip void
-u funkciju addTask() dodajemo funkciju setTasks()
-u jsx-u Form Elementu dodajemo prop addTask
-u prop addTask proslijedujemo funkciju addTask
-u komponenti Form.tsx kreiramo tip FormProps
-fukciji Form() dodajemo parametar destruktuirani prop addTask
-parametru addTask dodajemo tip FormProps
-u funkciju handleSubmit() dodajemo funkciju addTask()

119. Tasks Project - List
-u index.tsx fajlu kreiramo funkciju toggleTask() sa parametrom destruktuiranim prop id
-parametru id dodajemo tip string
-u funkciju toggleTask() dodajemo funkciju setTasks()
-u funkciju setTasks() dodajemo metodu tasks.map()
-u metodu map() dodajemo uslov if (task.id === id)
-u jsx-u komponenti List dodajemo prop tasks i toggleTask
-u prop tasks proslijedujemo varijablu tasks
-u prop toggleTask proslijedujemo funkciju toggleTask
-u komponentu List.tsx importujemo tip Task iz types.ts fajla
-kreiramo tip ListProps
-funkciji List() dodajemo parametre destruktuirane prop tasks i toggleTask
-parametrima dodajemo tip ListProps
-u jsx-u kreiramo ul element sa klasom list
-u ul element dodajemo metodu tasks.map()
-u metodi map() kreiramo elemente li i p
-kreiramo input element sa prop type, checked i dogadajem onChange
-u dogadaj onChange proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju toggleTask()

120. Tasks Project - Local Storage
-u index.tsx fajlu kreiramo funkciju loadTasks() sa tipom Task[]
-u funkciji loadTasks() kreiramo varijablu const storedTasks
-u return izjavu dodajemo logiku za dohvacanje taskova
-u funkciju useState() proslijedujemo funkciju loadTasks()
-kreiramo funkciju updateStorage() sa parametrom tasks koji ima tip Task[]
-funkciji updateStorage() dodajemo tip void
-u funkciju updateStorage() dodajemo metodu localStorage.setItem()
-kreiramo funkciju useEffect() sa dva argumenta
-prvi argument je anonimna funkcija, a drugi argument je niz [tasks]
-u anonimnu funkciju dodajemo funkciju updateStorage()


Section 05: Store App

121. Intro
-u terminalu instaliramo Vite React.js aplikaciju

122. Install/Setup
-dodajemo opis izrade projekta u README.md fajl
-u index.html fajl dodajemo ime projekta

123. Boilerplate
-obrisemo CSS stil u index.css fajlu
-obrisemo App.css fajl
-u komponenti App.tsx kreiramo funkciju App()
-u terminalu instaliramo potrebne pakete za projekt

124. Tailwind Intro

125. Tailwind Info

126. Tailwind Install
-u terminalu instaliramo Tailwind CSS paket

127. Important Update !!!

128. Shadcn/ui Install
-otvorimo web stranicu https://ui.shadcn.com/
-otvorimo link https://ui.shadcn.com/docs/installation/vite
-u terminalu instaliramo paket types/node
-u terminalu ukucamo komandu npx shadcn@latest init
-u terminalu ukucamo komandu npx shadcn@latest add button
-u komponentu App.tsx importujemo komponentu Button iz Shadcn

129. Shadcn/ui Info

130. Redux Toolkit - Setup
-u terminalu instaliramo pakete React Redux i Redux Toolkit
-u terminalu ukucamo komandu npm install @reduxjs/toolkit react-redux
-kreiramo folder features
-u folderu features kreiramo fajlove: cartSlite.ts, themeSlice.ts i userSlice.ts
-konfiguracija Redux Toolkit paketa

131. Create Pages
-u eslint.config.js fajl dodajemo opciju upozorenja za nekoristene varijable
-kreiramo folder pages i tsx komponente
-kreiramo index.ts fajl u kojem eksportujemo komponente kao default
-u komponentu App.tsx importujemo komponente iz index.ts fajl

132. React Router - Setup
-u terminalu instaliramo paket React Router Dom sa komandom npm i react-router-dom
-u komponentu App.tsx importujemo komponentu RouterProvider 
-importujemo i kreiramo funkciju createBrowserRouter()
-vrijednost funkcije createBrowserRouter() pohranjujemo u varijablu const router
-u jsx-u kreiramo komponentu RouterProvider sa prop router
-u prop router proslijedujemo vrijednost varijable router

133. Link Component
-u komponentu Link.tsx importujemo komponente Link i Button
-u jsx-u kreiramo komponente Link i Button
-komponenti Link dodajemo prop to i className
-komponenti Button dodajemo prop asChild i size

134. Outlet Component - Shared Layout
-u komponenti App.tsx, u funkciji createBrowserRouter() kreiramo objekt rute za komponente Login i Register
-u objekt ruti '/' kreiramo opciju niz children koji sadrzi objekt rute
-u komponentu HomeLayout.tsx importujemo komponentu Outlet iz paketa React Router Dom
-u komponenti App.tsx kreiramo objekt rutu index za komponentu Landing

135. Header Component
-u folderu components kreiramo komponentu Header.tsx
-kreiramo index.ts fajl u kojem eksportujemo komponentu Header.tsx kao default
-u komponentu Header.tsx importujemo komponentu Link i funkciju useNavigate iz paketa React Router Dom
-importujemo komponentu Button i funkciju useState
-kreiramo funkciju handleLogout()
-u jsx-u kreiramo HTML elemente kojima dodajemo Tailwind CSS klase
-kreiramo state varijablu const user i set funkciju setUser
-funkciji useState() dodajemo tipove string | null
-u funkciju handleLogout() dodajemo funkciju setUser(null)
-u jsx-u dodajemo ternarni uslov za varijablu user koji ce se elementi prikazivati na ekranu
-u jsx-u prvoj komponenti Button dodajemo prop variant, size i dogadaj onClick
-u dogadaj onClick proslijedujemo funkciju handleLogout
-drugoj i trecoj komponenti Button dodajemo prop asChild, variant i size
-kreiramo varijablu const navigate
-u komponentu HomeLayout.tsx importujemo komponentu Header.tsx
-u funkciju handleLogout() dodajemo funkciju navigate()

136. Tailwind Custom Class
-u index.css dodajemo opciju @layer components {}
-u objektu components kreiramo klasu align-element
-u komponenti HomeLayout.tsx kreiramo div element sa klasom align-element
-u div sa klasom align-element dodajemo komponentu Outlet

137. Navbar Component - Setup
-u folderu components kreiramo vise tsx komponenti 
-u index.ts fajlu eksportujemo kreiramo komponente kao default
-u komponentu Navbar.tsx importujemo vise tsx komponenti
-u komponenti Navbar.tsx, u jsx-u kreiramo nav element sa Tailwind CSS klasama
-u nav elementu kreiramo div element
-u div element dodajemo komponente Logo, LinksDropdown i NavLinks
-kreiramo jos jedan div element
-u div element dodajemo komponente ModeToggle i CartButton
-u komponentu HomeLayout.tsx importujemo komponentu Navbar.tsx

138. Logo Component
-otvorimo web stranicu https://lucide.dev/
-u komponentu Logo.tsx importujemo ikonicu Armchair iz paketa Lucide React
-importujemo i kreiramo komponentu Link u jsx-u
-komponenti Link dodajemo prop to i className

139. Links List
-kreiramo folder utils 
-u folderu utils kreiramo fajlove links.ts i index.ts
-u links.ts fajlu kreiramo tip Link
-eksportujemo i kreiramo niz varijablu const links sa tipom Link[]
-u nizu links kreiramo objekt rute
-u index.ts fajl dodajemo eksport *

140. Links Dropdown Component
-u terminalu ukucamo komandu npx shadcn@latest add dropdown-menu
-u komponentu LinksDropdown.tsx importujemo komponente DropdownMenu, DropdownMenuContent, DropdownMenuItem i DropdownMenuTrigger iz foldera components/ui
-u funkciji LinksDropdown() kreiramo komponentu DropdownMenu sa otvorenim i zatvorenim tagom
-u komponenti DropdownMenu kreiramo komponentu DropdownMenuTrigger sa otvorenim i zatvorenim tagom
-komponenti DropdownMenuTrigger dodajemo prop asChild i className
-u className dodajemo klasu lg:hidden
-u komponenti DropdownMenuTrigger kreiramo komponentu Button sa otvorenim i zatvorenim tagom
-komponenti Button dodajemo prop variant i size
-importujemo ikonicu AlignLeft iz paketa Lucide React
-u komponenti Button dodajemo ikonicu AlignLeft i span element
-kreiramo komponentu DropdownMenuContent sa otvorenim i zatvorenim tagom
-komponenti DropdownMenuContent dodajemo prop className, align i  sideOffset
-importujemo varijablu niz links iz foldera utils
-u komponentu DropdownMenuContent dodajemo metodu links.map()
-importujemo komponentu NavLink iz paketa React Router Dom
-u metodi map() kreiramo komponentu DropdownMenuItem sa otvorenim i zatvorenim tagom
-komponenti DropdownMenuItem dodajemo prop key
-u komponenti DropdownMenuItem kreiramo komponentu NavLink
-komponenti NavLink dodajemo prop to i className
-u prop className dodajemo anonimnu funkciju sa parametrom destruktuiranim prop isActive

141. NavLinks Component
-u komponentu NavLinks.tsx importujemo niz links i komponentu NavLink
-roditelj div elementu dodajemo Tailwind CSS klase
-u div element dodajemo metodu links.map()
-u funkciji map() kreiramo komponentu NavLink sa otvorenim i zatvorenim tagom
-komponenti NavLink dodajemo prop to, key i className
-u prop className dodajemo anonimnu funkciju sa destruktuiranim parametrom isActive

142. Change Theme
-otvorimo link https://ui.shadcn.com/docs/theming
-otvorimo link https://ui.shadcn.com/themes
-manje izmjene u bojama u index.css fajlu

143. ApplyTheme Function
-otvorimo link https://ui.shadcn.com/docs/dark-mode/vite
-u themeSlice.ts fajlu kreiramo i eksportujemo tip Theme
-u index.ts fajlu dodajemo eksport * za fajl applyTheme.ts
-kreiramo applyTheme.ts fajl
-u applyTheme.ts fajl importujemo tip Theme
-kreiramo i eksportujemo funkciju applyTheme() sa parametrom theme koji ima tip Theme
-u funkciji applyTheme() kreiramo varijablu const root
-varijabli root dodajemo metode classList i remove()
-dodajemo uslove if (theme === 'system')
-u uslovu if kreiramo varijablu const systemTheme
-varijabli root dodajemo metode classList i add()
-dodajemo return izjavu
-nakon uslova if dodajemo metodu root.classList.add(theme)

144. Theme Slice
-u themeSlice.ts fajlu importujemo tip PayloadAction iz paketa Redux Toolkit
-importujemo funkciju applyTheme iz foldera utils
-kreiramo tip ThemeState
-kreiramo funkciju initializeTheme() koja ima tip Theme
-u funkciji initializeTheme() kreiramo varijablu const theme
-dodajemo funkciju applyTheme(theme)
-dodajemo izjavu return theme
-kreiramo varijablu const initialState sa tipom ThemeState
-u objekt dodajemo key - value par theme: initializeTheme()
-u objektu reducers kreiramo funkciju setTheme() sa parametrim state i action
-parametru action dodajemo tip PayloadAction<Theme>
-u funkciju setTheme() dodajemo state.theme
-dodajemo funkciju applyTheme(action.payload)
-dodajemo metodu localStorage.setItem()

145. ModeToggle Component
-u ModeToggle.tsx fajl importujemo i kreiramo funkciju useAppDispatch()
-vrijednost funkcije useAppDispatch() pohranjujemo u varijablu const dispatch
-u komponentu ModeToggle.tsx importujemo komponente iz paketa dropdown-menu.tsx
-importujemo komponentu Button iz button.tsx fajla
-komponentama DropdownMenuItem dodajemo dogadaje onClick
-u dogadaje onClick proslijedujemo anonimne funkcije 
-u anonimne funkcije proslijedujemo funkcije dispatch()

146. CartButton Component
-u komponenti CartButton.tsx kreiramo varijablu const numItemsInCart = 5
-u komponentu CartButton.tsx importujemo komponentu Button
-u jsx-u kreiramo komponentu Button sa otvorenim i zatvorenim tagom
-komponenti Button dodajemo prop asChild, variant, size i className
-importujemo komponentu Link i ikonicu ShoppingCart
-u komponenti Button kreiramo komponentu Link sa otvorenim i zatvorenim tagom
-u komponentu Link dodajemo ikonicu ShoppingCart i span element

147. ErrorPage Component
-u komponentu Error.tsx importujemo i kreiramo funkciju useRouteError()
-vrijednost funkcije useRouteError() pohranjujemo u varijablu const error
-importujemo funkciju isRouteErrorResponse
-dodajemo uslov if da provjerimo da li error postoji
-u uslov if dodajemo return izjavu 
-u return izjavi kreiramo HTML elemente sa Tailwind CSS klasama
-importujemo komponente Button i Link
-u jsx-u kreiramo main element
-u komponenti App.tsx, u objekt rutu za komponentu HomeLayout dodajemo key - value opciju errorElement i komponentu Error
-u objekt rute za komponente Login i Register dodajemo isto key - value opciju errorElement i komponentu Error

148. About Page Component
-u komponenti About.tsx kreiramo HTML elemente sa Tailwind CSS klasama

149. Error Element Component
-u folderu components kreiramo komponentu ErrorElement.tsx
-u komponentu ErrorElement.tsx importujemo i kreiramo funkciju useRouteError iz paketa React Router Dom
-vrijednost funkcije useRouteError() pohranjujemo u varijablu const error
-u jsx-u kreiramo h4 element
-u index.ts fajlu eksportujemo komponentu ErrorElement.tsx kao default
-u komponentu App.tsx importujemo komponentu ErrorElement.tsx
-u nizu children, u objekt rute dodajemo key - value parove errorElement i komponentu ErrorElement

150. Landing Page - Setup
-u folderu components kreiramo pet tsx komponenti
-kreirane tsx komponente eksportujemo kao default u index.ts fajlu
-u komponentu Landing.tsx importujemo komponente Hero.tsx i FeaturedProducts.tsx

151. Custom Fetch Function
-otvorimo link: https://documenter.getpostman.com/view/18152321/2s9Xy5KpTi
-u folderu utils kreiramo customFetch.ts fajl
-u customFetch.ts fajl importujemo instancu axios
-kreiramo varijablu const productionUrl
-kreiramo i eksportujemo varijablu customFetch

152. Product Types
-u folderu utils kreiramo types.ts fajl
-u types.ts fajlu kreiramo i eksportujemo tipove ProductsResponse, Product, ProductsMeta i Pagination
-otvorimo link: https://strapi-store-server.onrender.com/api/products

153. Loader Function
-u komponenti App.tsx, u objekt rutu za komponentu Landing dodan key - value par loader i asinhrona funkcija

154. Landing Page - Loader
-u komponentu Landing.tsx importujemo funkciju useLoaderData i tip LoaderFunction
-kreiramo anonimna asinhronu funkciju 
-vrijednost anonimne asinhrone funkcije pohranjujemo u varijablu const loader
-varijabli loader dodajemo tip LoaderFunction
-eksportujemo varijablu loader
-u komponentu App.tsx importujemo funkciju loader kao landingLoader
-u key - value par dodajemo loader: landingLoader
-u komponentu Landing.tsx importujemo funkciju customFetch i tip ProductsResponse iz foldera utils
-kreiramo varijablu const url
-u anonimnu funkciju dodajemo metodu await customFetch(url)
-funkciji customFetch dodajemo tip <ProductsResponse>
-vrijednost funkcije customFetch() pohranjujemo u varijablu const response
-anonimnoj funkciji dodajemo tip Promise<ProductsResponse>
-u funkciju Landing() dodajemo pozivamo funkciju useLoaderData() as ProductsResponse
-vrijednost funkcije useLoaderData() pohranjujemo u varijablu const result

155. Section Title
-otvorimo link: https://ui.shadcn.com/docs/components/separator
-u terminalu instaliramo komponentu Separator sa komandom npx shadcn@latest add separator
-u komponentu SectionTitle.tsx importujemo komponentu Separator
-funkciji SectionTitle() dodajemo parametar destruktuirani prop text
-parametru text dodajemo tip string
-u komponentu FeaturedProducts.tsx importujemo komponente SectionTitle.tsx i ProductsGrid.tsx
-u funkcije FeaturedProducts() kreiramo section element 
-u jsx-u komponenti SectionTitle dodajemo prop text

156. FormatAsDollars Function
-u folderu utils kreiramo formatAsDollars.ts fajl
-u formatAsDollars.ts fajlu kreiramo i eksportujemo funkciju formatAsDollars()
-funkciji formatAsDollars() dodajemo parametar price koji moze imati tip string ili number
-funkcije formatAsDollars() dodajemo tip string
-u funkciji formatAsDollars() kreiramo varijablu const dollarsAmount
-dodajemo izjavu return dollarsAmount
-u index.ts fajl dodajemo eksport * za fajl formatAsDollars.ts

157. Products Grid Component
-otvorimo link https://ui.shadcn.com/docs/components/card
-u terminalu instaliramo komponentu Card sa komandom npx shadcn@latest add card
-u komponentu ProductsGrid.tsx importujemo i kreiramo funkciju useLoaderData
-vrijednost funkcije useLoaderData() pohranjujemo u varijablu const { data: products }
-roditelj div elementu dodajemo Tailwind CSS klase
-u div element dodajemo metodu products.map()
-destruktuiramo varijable const { title, price, image }
-importujemo i kreiramo funkciju formatAsDollars(price)
-vrijednost funkcije formatAsDollars(price) pohranjujemo u varijablu const dollarsAmount
-u funkciji map() kreiramo komponentu Link
-komponenti Link dodajemo prop to i key
-importujemo komponente Card i CardContent iz ui/card.tsx fajla
-u komponenti Link kreiramo komponentu Card sa otvorenim i zatvorenim tagom
-u komponenti Card kreiramo komponentu CardContent sa otvorenim i zatvorenim tagom
-u komponenti CardContent kreiramo HTML elemente img, div, h2 i p
-HTML elementima dodajemo Tailwind CSS klase

158. Hero Component
-u komponentu Hero.tsx importujemo komponente Link i Button iz paketa React Router Dom
-importujemo komponentu HeroCarousel.tsx
-u jsx-u kreiramo HTML elemente section, div, h1 i p
-HTML elementima dodajemo Tailwind CSS klase
-u div elementu kreiramo komponentu Button 
-komponenti Button dodajemo prop asChild, site i className
-u komponenti Button kreiramo komponentu Link

159. Hero Carousel
-otvorimo link: https://ui.shadcn.com/docs/components/carousel
-u terminalu instaliramo komponentu Carousel sa komandom npx shadcn@latest add carousel
-u folder assets dodajemo cetiri slike
-u komponentu HeroCarousel.tsx importujemo komponente iz fajlova carousel.tsx i card.tsx
-kreiramo varijablu niz const carouselImages koji se sastoji od importovanih slika
-u funkcije HeroCarousel() roditelj div elementu dodajemo Tailwind CSS klase
-u div elementu kreiramo komponentu Carousel sa otvorenim i zatvorenim tagom
-u komponenti Carousel kreiramo komponentu CarouselContent sa otvorenim i zatvorenim tagom
-u komponentu CarouselContent dodajemo metodu carouselImages.map()
-u map() funkciji kreiramo komponentu CarouselItem sa otvorenim i zatvorenim tagom
-u komponenti Carousel kreiramo komponentu Card sa otvorenim i zatvorenim tagom
-u komponenti Card kreiramo komponentu CardContent sa otvorenim i zatvorenim tagom
-u komponentu CardContent kreiramo img element
-u komponenti Carousel kreiramo komponente CarouselPrevious i CarouselNext

160. Products Page - Setup
-u folderu components kreiramo cetiri komponente
-u index.ts fajlu eksportujemo komponente kao default
-kreiramo varijablu const url
-importujemo funkciju customFetch i tip ProductsResponse iz foldera utils
-kreiramo asinhronu funkciju sa tipom Promise<ProductsResponse>
-importujemo tip loader iz paketa React Router Dom
-vrijednost anonimne funkcije pohranjujemo u varijablu const loader sa tipom LoaderFunction
-u anonimnu funkciju dodajemo funkciju await customFetch()
-vrijednost funkcije await customFetch() pohranjujemo u varijablu const response
-eksportujemo varijablu loader
-importujemo komponentama Filters, ProductsContainer i PaginationContainer
-u komponentu App.tsx importujemo funkciju loader kao productsLoader iz komponente Products.tsx
-u objekt rutu za komponentu Products dodajemo key - value par loader i funkciju productsLoader

161. Products List Component
-u komponentu ProductsList.tsx import funkciju useLoaderData i komponentu Link iz paketa React Router Dom
-importujemo funkciju formatAsDollars i tip ProductsResponse iz foldera utils
-kreiramo funkciju useLoaderData() as ProductsResponse
-vrijednost funkcije useLoaderData() pohranjujemo u varijablu const { data: products }
-u jsx-u, roditelj div elementu dodajemo Tailwind CSS klase
-u div element dodajemo metodu products.map()
-u funkciji map() kreiramo komponentu Link
-komponenti Link dodajemo prop key i to
-destruktuiramo varijable const { title, price, image, company }
-importujemo komponente Card i CardContent iz komponente ui/card.tsx
-kreiramo komponentu Card sa otvorenim i zatvorenim tagom
-u komponenti Card kreiramo komponentu CardContent sa otvorenim i zatvorenim tagom
-komponenti CardContent dodajemo Tailwind CSS klase
-u komponenti CardContent kreiramo HTML img element
-kreiramo HTML elemente div, h2, h4 i p
-HTML elementima dodajemo Tailwind CSS klase
-kreiramo varijablu const dollarsAmount 
-u komponentu ProductsContainer.tsx importujemo komponentu ProductsList.tsx

162. Products Container Component
-u komponentu ProductsContainer.tsx importujemo i kreiramo funkciju useLoaderData() as ProductsResponse
-importujemo tip ProductsResponse iz foldera utils
-vrijednost funkcije useLoaderData() pohranjujemo u destruktuiranu varijablu const { meta }
-kreiramo varijablu const totalProducts
-importujemo funkciju useState
-kreiramo state varijablu const layout i set funkciju setLayout
-funkciji useState('grid') dodajemo tip <'grid' | 'list'>
-u jsx-u kreiramo section element
-u section elementu kreiramo dva elemente div
-u prvom div elementu kreiramo h4 element za prikazivanje ukupnog broja proizvoda
-importujemo komponentu Button iz komponente ui/button.tsx 
-importujemo ikonice LayoutGrid i List iz paketa Lucide React
-importujemo komponentu Separator iz komponente ui/separator.tsx
-u drugom div elementu kreiramo dvije komponente Button sa otvorenim i zatvorenim tagom
-komponentama Button dodajemo prop variant, size i dogadaj onClick
-u dogadaj onClick proslijedujemo funkciju setLayout()
-u prop variant dodajemo ternarni operator za varijablu layout
-importujemo komponente LayoutGrid.tsx i ProductsList.tsx
-kreiramo div element za proizvode
-u div element dodajemo ternarni uslov za varijablu totalProducts

163. Global Loading - Setup
-u folderu components kreiramo komponentu Loading.tsx
-u index.ts fajlu eksportujemo komponentu Loading.tsx kao default
-u komponentu HomeLayout.tsx importujemo i kreiramo funkciju useNavigation iz paketa React Router Dom
-vrijednost funkcije useNavigation() pohranjujemo u varijablu const navigation
-kreiramo varijablu const isPageLoading
-importujemo komponentu Loading.tsx
-u div element dodajemo ternarni operator za varijablu isPageLoading 

164. Loading Component
-otvorimo link: https://ui.shadcn.com/docs/components/skeleton
-u terminalu instaliramo komponentu Skeleton sa komandom npx shadcn@latest add skeleton
-u komponentu Loading.tsx importujemo komponentu Skeleton iz komponente ui/skeleton.tsx
-u jsx-u, roditelj div elementu dodajemo Tailwind CSS klase
-u div element dodajemo metodu Array.from({ ... }).map()
-u funkciji map(), u return izjavi kreiramo roditelj div element
-u div element kreiramo tri komponente Skeleton

165. Filters Component - Setup
-otvorimo link: https://ui.shadcn.com/docs/components/form
-u terminalu instaliramo vise Shadcn komponenti sa komandom npx shadcn@latest add label input select slider checkbox
-u komponentu Filters.tsx importujemo komponente Form i Link iz paketa React Router Dom
-importujemo komponente Input, Label i Button iz foldera ui
-u jsx-u kreiramo roditelj komponentu Form sa Tailwind CSS klasama
-u komponenti Form kreiramo div element 
-u div elementu kreiramo komponente Label i Input
-komponenti Input dodajemo prop id, name, type i defaultValue
-kreiramo dvije komponente Button
-komponentama Button dodajemo vise prop

166. Query Params
-u Products.tsx fajlu kreiramo varijablu const params

167. Default Value
-u types.ts fajlu kreiramo i eksportujemo tip Params
-kreiramo i eksportujemo tip ProductsResponseWithParams
-u komponentu Products.tsx importujemo tip ProductsResponseWithParams
-u funkciju loader dodajemo tip ProductsResponseWithParams
-u komponenti Filters.tsx importujemo i kreiramo funkciju useLoaderData()
-importujemo tip ProductsResponseWithParams
-vrijednost funkcije useLoaderData() pohranjujemo u destruktuirane varijable const { meta, params }
-iz varijable params destruktuiramo varijablu const { search }

168. Form Input
-u folderu components kreiramo komponente Label i Input iz foldera ui
-kreiramo tip FormInputProps
-funkciji FormInput() dodajemo parametre destruktuirane prop label, name, type i defaultValue
-parametrima prop dodajemo tip FormInputProps
-u jsx-u kreiramo komponente Label i Input 
-komponenti Label dodajemo prop htmlFor i className
-komponenti Input dodajemo prop id, name, type i defaultValue
-u index.ts fajlu eksportujemo komponentu FormInput.tsx kao default
-u komponentu Filters.tsx importujemo komponentu FormInput.tsx
-iz varijable paramas destruktuiramo varijable const { search, company, category, shipping, order, price }
-u jsx-u dodajemo komponentu FormInput sa prop type, label, name i defaultValue
-u prop defaultValue proslijedujemo vrijednost varijable search

169. Form Select
-otvorimo link: https://ui.shadcn.com/docs/components/select
-u folderu components kreiramo komponentu FormSelect.tsx
-u terminalu instaliramo Shadcn komponentu Select sa komandom npx shadcn@latest add select
-u komponenti FormSelect.tsx kreiramo tip SelectInputProps
-importujemo komponentu Label iz komponente ui/labale.tsx
-importujemo komponente Select, SelectContent, SelectItem, SelectTrigger, SelectValue iz komponente ui/select.tsx
-funkciji FormSelect() dodajemo parametre destruktuirane prop label, name, options i defaultValue
-destruktuiranim parametrima prop dodajemo tip SelectInputProps
-u jsx-u kreiramo roditelj div element
-u div elementu kreiramo komponentu Label sa otvorenim i zatvorenim tagom
-komponenti Label dodajemo prop htmlFor i className
-kreiramo komponentu Select sa otvorenim i zatvorenim tagom
-komponenti Select dodajemo prop default i name
-u komponenti Select kreiramo komponentu SelectTrigger sa otvorenim i zatvorenim tagom
-komponenti SelectTrigger dodajemo prop id
-u komponentu SelectTrigger kreiramo komponentu SelectValue 
-u komponenti Select kreiramo komponentu SelectContent sa otvorenim i zatvorenim tagom
-u komponentu SelectContent dodajemo metodu options.map()
-u funkciji map() kreiramo komponentu SelectItem
-komponenti SelectItem dodajemo prop key i value
-u komponentu Filters.tsx importujemo komponentu FormSelect.tsx
-u jsx-u kreiramo tri komponente FormSelect za kategorije, kompanije i narudzbe

170. Form Range
-otvorimo link: https://ui.shadcn.com/docs/components/slider
-u terminalu instaliramo Shadcn komponentu Slider sa komandom npx shadcn@latest add slider
-u folderu components kreiramo komponentu FormRange.tsx
-u index.ts fajlu eksportujemo komponentu FormRange.tsx kao default
-u komponentu Filters.tsx importujemo komponentu FormRange.tsx
-u jsx-u, komponenti FormRange dodajemo prop label, name i defaultValue
-u prop defaultValue proslijedujemo vrijednost varijable price
-u komponentu FormRange.tsx importujemo funkciju useState
-importujemo funkciju formatAsDollars iz foldera utils
-importujemo komponente Label i Slider iz foldera ui
-kreiramo tip FormRangeProps
-funkciji FormRange() dodajemo parametre destruktuirane prop name, label i defaultValue
-destruktuiranim parametrima dodajemo tip FormRangeProps
-kreiramo varijable const const step, const maxPrice i const defaultPrice
-kreiramo state varijablu const selectedPrice i set funkciju setSelectedPrice
-u jsx-u kreiramo roditelj div element
-u roditelj div elementu kreiramo komponentu Label sa otvorenim i zatvorenim tagom
-komponenti Label dodajemo prop htmlFor i className
-kreiramo HTML span element
-u span element dodajemo funkciju formatAsDollars(selectedPrice)
-u div elementu kreiramo komponentu Slider sa samozatvarajucim tagom
-komponenti Slider dodajemo prop id, name, step, max, value, onValueChange i className
-u prop onValueChange proslijedujemo anonimnu funkciju sa parametrom value
-u anonimnu funkciju sa parametrom value proslijedujemo funkciju setSelectedPrice()

171. Form Checkbox
-otvorimo link: https://ui.shadcn.com/docs/components/checkbox
-u terminalu instaliramo Shadcn komponentu Checkbox sa komandom npx shadcn@latest add checkbox
-u folderu components kreiramo komponentu FormCheckbox.tsx
-u index.ts eksportujemo komponentu FormCheckbox.tsx kao default
-u komponentu Filters.tsx importujemo komponentu FormCheckbox.tsx
-u jsx-u kreiramo komponentu FormCheckbox
-komponenti FormCheckbox dodajemo prop label, name i defaultValue
-u prop defaultValue proslijedujemo vrijednost varijable shipping
-u komponentu FormCheckbox.tsx importujemo komponente Label i Checkbox iz foldera ui
-kreiramo tip FormCheckboxProps
-funkciji FormCheckbox() dodajemo parametre destruktuirane prop name, label i defaultValue
-destruktuiranim parametrima dodajemo tip FormCheckboxProps
-u funkciji FormCheckbox() kreiramo varijablu const defaultChecked
-u jsx-u kreiramo komponentu Label sa otvorenim i zatvorenim tagom
-komponenti Label dodajemo prop htmlFor i className
-kreiramo komponentu Checkbox sa samozatvarajucim tagom
-komponenti Checkbox dodajemo prop id, name i defaultChecked
-u prop defaultChecked proslijedujemo vrijednost varijable defaultChecked

172. Pagination Container - Setup
-otvorimo web stranicu: https://ui.shadcn.com/docs/components/pagination
-u terminalu instaliramo Shadcn komponentu Pagination sa komandom npx shadcn@latest add pagination
-u pagination.tsx fajl importujemo komponentu Link

173. Construct URL - Setup
-u folderu utils kreiramo pagination.ts fajl
-u index.ts fajlu dodajemo eksport * za fajl pagination.ts
-u pagination.ts fajlu kreiramo tip ConstructUrlParams
-kreiramo i eksportujemo funkciju constructUrl()
-funkciji constructUrl() dodajemo parametre destruktuirane prop pageNumber, search i pathname
-destruktuiranim parametrima dodajemo tip ConstructUrlParams
-funkciji constructUrl() dodajemo tip string
-u return izjavu dodajemo string '/products'
-kreiramo tip ConstructPrevOrNextParams
-kreiramo i eksportujemo funkciju constructPrevOrNextUrl()
-funkciji constructPrevOrNextUrl() dodajemo paramere destruktuirane prop currentPage, pageCount, search i pathname
-destruktuiranim parametrima dodajemo tip ConstructPrevOrNextParams
-funkciji constructPrevOrNextUrl() dodajemo objekt tip
-u funkciji constructPrevOrNextUrl() kreiramo varijable const prevUrl i nextUrl
-dodajemo return izjavu u koju dodajemo varijable prevUrl i nextUrl

174. Pagination Container
-u komponentu PaginationContainer.tsx import komponente iz komponente ui/pagination.tsx
-importujemo tip ProductsResponseWithParams, funkcije constructUrl i constructPrevOrNextUrl iz foldera utils
-importujemo funkcije useLoaderData, useLocation iz paketa React Router Dom
-kreiramo funkcije useLoaderData() i useLocation()
-vrijednost funkcije useLoaderData() as ProductsResponseWithParams pohranjujemo u destruktuiranu varijablu const { meta }
-iz varijable meta destruktuiramo varijable const { pageCount, page }
-vrijednost funkcije useLocation() pohranjujemo u destruktuirane varijable const { search, pathname }
-dodajemo metodu Array.from()
-vrijednost metode Array.from() pohranjujemo u varijablu const pages
-dodajemo uslov if (pageCount < 2)
-dodajemo metodu pages.map()
-vrijednost metode pages.map() pohranjujemo u varijablu const renderPagination
-u funkciji map() kreiramo varijable const isActive i const url
-u return izjavi kreiramo komponentu PaginationItem sa otvorenim i zatvorenim tagom
-komponenti PaginationItem dodajemo prop key
-u komponenti PaginationItem kreiramo komponentu PaginationLink sa otvorenim i zatvorenim tagom
-komponenti PaginationLink dodajemo prop to i isActive
-vrijednost funkcije constructPrevOrNextUrl() pohranjujemo u destruktuirane varijable const { prevUrl, nextUrl }
-u jsx-u kreiramo roditelj komponentu Pagination sa otvorenim i zatvorenim tagom
-u komponenti Pagination kreiramo komponentu PaginationContent sa otvorenim i zatvorenim tagom
-u komponenti PaginationContent kreiramo dvije komponente PaginationItem sa otvorenim i zatvorenim tagom
-u prvoj komponenti PaginationItem kreiramo komponentu PaginationPrevious sa samozatvarajucim tagom
-komponenti PaginationPrevious dodajemo prop to 
-u prop to proslijedujemo vrijednost varijable prevUrl
-u drugoj komponenti PaginationItem kreiramo komponentu PaginationNext sa samozatvarajucim tagom
-komponenti PaginationNext dodajemo prop to 
-u prop to proslijedujemo vrijednost varijable nextUrl
-izmedu dvije komponente PaginationItem dodajemo varijablu {renderPagination}

175. Construct URL - Complete
-u pagination.ts fajlu, u funkciji constructUrl()
-u funkciji constructUrl() kreiramo varijablu const searchParams
-varijabli searchParams() dodajemo funkciju set()
-dodajemo u return izjavu string
-u funkciji constructPrevOrNextUrl() kreiramo varijablu let prevPage
-dodajemo uslov if (prevPage < 1)
-u uslov if (prevPage < 1) dodajemo prevPage = pageCount
-nakon uslova if dodajemo funkciju constructUrl()
-vrijednost funkcije constructUrl() pohranjujemo u varijablu const prevUrl
-kreiramo varijablu let nextPage
-dodajemo uslov if (prevPage < 1)
-u uslov if (nextPage > 1) dodajemo nextPage = 1
-nakon uslova if dodajemo funkciju constructUrl()
-vrijednost funkcije constructUrl() pohranjujemo u varijablu const nextUrl

176. React Router - URL Params

177. Single Product Page - Setup
-u folderu components kreiramo komponente SelectProductColor.tsx i SelectProductAmount.tsx
-u index.ts fajlu eksportujemo kreirane komponente kao default
-u komponentu SingleProduct.tsx kreiramo i eksportujemo asinhronu loader() funkciju sa destruktuiranim parametrom params
-importujemo tip LoaderFunction iz paketa React Router Dom
-funkciji loader() dodajemo tip LoaderFunction
-u komponentu App.tsx importujemo funkciju loader kao singleProductLoader
-u objekt rutu za komponentu SingleProduct dodajemo key - value par loader i funkciju singleProductLoader

178. Fetch Single Product
-u komponentu SingleProduct.tsx importujemo i kreiramo funkciju useLoaderData()
-importujemo funkciju useState
-u anonimnu asinhronu funkciju dodajemo tip Promise<SingleProductResponse>
-importujemo funkcije customFetch, formatAsDollars i tip SingleProductResponse iz foldera utils
-u funkciju loader() dodajemo funkciju await customFetch<SingleProductResponse>()
-vrijednost funkcije customFetch() pohranjujemo u varijablu const response
-u return izjavu dodajemo { ...response.data }
-vrijednost funkcije useLoaderData() pohranjujemo u destruktuirane varijable { data: product }
-vrijednost varijable product.attributes pohranjujemo u destruktuirane varijable
-vrijednost funkcije formatAsDollars(price) pohranjujemo u varijablu const dollarsAmount
-kreiramo state varijablu const productColor i set funkciju setProductColors()
-kreiramo state varijablu const amount i set funkciju set funkciju setAmount
-kreiramo funkciju addToCart()
-u eslint.config.js fajlu, u konfiguracioni objekt dodana opcija allowExportNames: ['loader']

179. Single Product Page - Render Image and Info
-u jsx-u kreiramo section element kao roditelj element
-u section elementu kreiramo div element sa Tailwind CSS klasama
-importujemo komponentu Link iz paketa React Router Dom
-importujemo komponente Button i Separator iz foldera components/ui
-u div elementu kreiramo komponentu Button sa otvorenim i zatvorenim tagom
-komponenti Button dodajemo prop asChild, variant i size
-u komponentu Button dodajemo komponentu Link
-kreiramo komponentu Separator
-kreiramo jos jedan Button element
-kreiramo div element za proizvod
-u div elementu za proizvod kreiramo img element
-kreiramo div element za informacije o proizvodu
-kreiramo element h2, h4 i p
-importujemo komponente SelectProductAmount.tsx i SelectProductColor.tsx
-u jsx-u dodajemo importovane komponente
-kreiramo komponentu Button za dodavanje proizvoda u korpu
-komponenti Button dodajemo prop size, className i onClick
-u dogadaj onClick proslijedujemo funkciju addToCart

180. Select Product Colors Component
-u komponenti SingleProduct.tsx, komponenti SelectProductColor dodajemo prop colors, productColor i setProductColor
-u komponenti SelectProductColor.tsx kreiramo tip SelectProductColorProps
-funkciji SelectProductColor() dodajemo parametre destruktuirane prop colors, productColor i setProductColor
-destruktuiranim parametrima dodajemo tip SelectProductColorProps
-u jsx-u kreiramo HTML elemente kojima dodajemo Tailwind CSS klase
-u div element sa klasom mt-2 dodajemo metodu colors.map()
-u funkciji map(), u return izjavi kreiramo button element
-button elementu dodajemo prop type, key, className, style i onClick
-u prop className dodajemo dinamicku klasu
-u dogadaj onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju setProductColor(color)

181. Select Product Amount Component
-u komponentu SelectProductAmount.tsx importujemo komponente iz komponente ui/select.tsx
-kreiramo i eksportujemo enum Mode
-u komponentu SingleProduct.tsx importujemo enum Mode
-u jsx-u, komponenti SelectProductAmount dodajemo prop mode, amount i setAmount
-u komponenti SelectProductAmount.tsx kreiramo dva tipa SelectProductAmountProps i SelectCartItemAmountProps
-funkciji SelectProductAmount() dodajemo parametre destruktuirane prop mode, amount i setAmount
-destruktuiranim parametrima dodajemo tipove SelectProductAmountProps | SelectCartItemAmountProps
-kreiramo varijablu const cartItem
-u jsx-u kreiramo h4 element sa Tailwind CSS klasama
-kreiramo komponentu Select sa otvorenim i zatvorenim tagom
-komponenti Select dodajemo prop defaultValue i onValueChange
-u komponenti Select kreiramo komponentu SelectTrigger sa otvorenim i zatvorenim tagom
-komponenti SelectTrigger dodajemo dinamicku klasu
-u komponenti SelectTrigger kreiramo komponentu SelectValue sa samozatvarajucim tagom
-kreiramo komponentu SelectContent sa otvorenim i zatvorenim tagom
-u komponentu SelectContent dodajemo metodu Array.from()
-u funkciju from() dodajemo dva argumenta: objekt i anonimnu funkciju
-u anonimnoj funkciji kreiramo varijablu const selectValue
-u return izjavi kreiramo komponentu SelectItem sa otvorenim i zatvorenim tagom
-komponenti SelectValue dodajemo prop key i value
-u komponentu SelectItem dodajemo varijablu {selectValue}

182. Toast Component
-otvorimo link: https://ui.shadcn.com/docs/components/toast
-u terminalu instaliramo Shadcn komponentu Toast sa komandom npx shadcn@latest add toast
-u folderu ui generisane komponente toast.tsx i toaster.tsx
-generisan folder hooks i use-toast.ts fajl
-u komponentu main.tsx importujemo komponentu Toaster iz komponente ui/Toaster.tsx

183. Cart Slice - Setup
-u cartSlice.ts fajl importujemo tip PayloadAction iz Reduxjs Toolkit paketa
-importujemo tipove CartItem i CartSlice iz foldera utils
-importujemo funkciju toast() iz ui/use-toast.ts fajla
-kreiramo varijablu const defaultState sa tipom CartState-
-kreiramo funkciju getCartFromLocalStorage() sa tipom CartState
-u funkcije getCartFromLocalStorage() kreiramo varijablu const cart
-u return izjavu dodajemo ternarni operator za varijablu cart
-u funkciji createSlice(), u objekt dodajemo key - value par initialState: getCartFromLocalStorage()
-u objektu reducers kreiramo funkcije: addItem(), clearCart(), removeItem(), editItem() i calculateTotals()
-eksportujemo funkcije kao cartSlice.actions

184. Add Item - Reducer
-u cartSlice.ts fajlu funkciji addItem() dodajemo parametre state i action
-parametru action dodajemo tip PayloadAction<CartItem>
-u funkciji addItem() kreiramo varijablu const newCartItem
-dodajemo metodu state.cartItems.find()
-vrijednost metode state.cartItems.find() pohranjujemo u varijablu const item
-dodajemo uslov if (item) - else
-u uslov if (item) dodajemo item.amount
-u uslov else dodajemo metodu state.cartItems.push(newCartItem)
-dodajemo metodu cartSlice.caseReducers
-dodajemo funkciju toast()
-u funkciju calculateTotals() dodajemo metode state.tax, state.orderTotal i localStorage.setItem()

185. Clear Cart - Reducer
-u cartSlice.ts fajlu, u funkciju clearCart() dodajemo localStorage.setItem()
-dodajemo return defaultState

186. Delete Item - Reducer
-u cartSlice.ts fajlu, funkciji removeItem() dodajemo parametre state i action
-parametru action dodajemo tip PayloadAction<string>
-kreiramo varijablu const cartID
-dodajemo metodu state.cartItems.find()
-vrijednost metode state.cartItems.find() pohranjujemo u varijablu const cartItem
-dodajemo uslov if (!cartItem) return
-dodajemo metode state.cartItems, state.numItemsInCart i state.cartTotal 
-dodajemo metodu cartSlice.caseReducers.calculateTotals(state)
-dodajemo funkciju toast()

187. Edit Item - Reducer
-u cartSlice.ts fajlu, funkciji editItem() dodajemo parametre state i action
-parametru action dodajemo tip PayloadAction<>
-destruktuiramo varijable const { cartID, amount }
-dodajemo metodu state.cartItems.find()
-vrijednost metode state.cartItems.find() pohranjujemo u varijablu const cartItem
-dodajemo uslov if (!cartItem) return
-dodajemo metodu state.numItemsInCart i state.cartTotal
-dodajemo metodu cartItem.amount = amount
-dodajemo metodu cartSlice.caseReducers.calculateTotals(state)
-dodajemo funkciju toast()

188. AddToCart Functionality
-u komponentu CartButton.tsx importujemo i kreiramo funkciju useAppSelector() iz foldera hooks
-vrijednost funkcije useAppSelector() pohranjujemo u varijablu const numItemsInCart
-u komponentu SingleProduct.tsx importujemo i kreiramo funkciju useAppDispatch() -importujemo funkciju addItem iz cartSlice.ts fajla
-importujemo tip CartItem iz foldera utils
-kreiramo varijablu const cartProduct sa tipom CartItem
-vrijednost funkcije useAppDispatch() pohranjujemo u varijablu const dispatch
-u funkciju addToCart() dodajemo funkciju dispatch(addItem(cartProduct))

189. Cart Page - Setup
-u folderu components kreiramo tri komponente CartItemColumns.tsx, CartItemsList i cartTotals.tsx
-u index.ts fajlu eksportujemo kreirane komponente
-u komponenti Cart.tsx kreiramo varijablu const user
-importujemo i kreiramo funkciju useAppSelector() iz foldera hooks
-vrijednost funkcije useAppSelector() pohranjujemo u varijablu const numItemsInCart
-importujemo komponentu SectionTitle.tsx
-dodajemo uslov if (numItemsInCart === 0)
-u uslov if dodajemo komponentu SectionTitle.tsx sa prop 'Empty Cart'
-u jsx-u kreiramo roditelj element <> </> 
-kreiramo komponentu SectionTitle sa prop text 'Shopping Cart'
-komponenti SectionTitle dodajemo prop text
-kreiramo div element sa klasom lg:grid-cols-12 sa Tailwind CSS klasama
-u div elementu lg:grid-cols-12 kreiramo div element sa klasom lg:col-span-8
-importujemo komponente CartItemsList.tsx i cartTotals.tsx
-u div elementu dodajemo komponentu CartItemsList
-kreiramo div element sa klasom lg:col-span-4
-u div element sa klasom lg:col-span-4 dodajemo komponentu CartTotals
-dodajemo uslov ternarni operator za varijablu user

190. Cart Totals Component
-u CartTotals.tsx komponenti kreiramo funkciju CartTotalRow()
-funkciji CartTotalRow() dodajemo parametre destruktuirane prop label, amount, lastRow
-destruktuiranim parametrima dodajemo tipove
-u jsx-u kreiramo HTML elemente p i span
-importujemo funkciju formatAsDollars iz foldera utils
-importujemo komponentu Separator iz komponente ui/separator.tsx
-u span element dodajemo funkciju formatAsDollars(amount)
-dodajemo ternarni uslov za varijablu lastRow
-importujemo i kreiramo funkciju useAppSelector() iz foldera hooks
-vrijednost funkcije useAppSelector() pohranjujemo u destruktuirane varijable const { cartTotal, shipping, tax, orderTotal }
-importujemo komponente Card i CardTitle iz komponente ui/card.tsx
-u jsx-u kreiramo komponentu Card sa otvorenim i zatvorenim tagom
-komponenti Card dodajemo Tailwind CSS klase
-u komponenti Card kreiramo tri komponente CartTotalRow sa samozatvarajucim tagom
-kreiramo komponentu CardTitle sa otvorenim i zatvorenim tagom
-u komponenti CardTitle kreiramo komponentu CartTotalRow sa samozatvarajucim tagom
-komponentama CartTotalRow dodajemo prop label i amount
-zadnjoj komponenti CartTotalRow dodajemo prop lastRow
-logiku iz komponente CartTotals.tsx za funkciju CartTotalRow() premjestamo u komponentu CartTotalRow.tsx
-u komponentu CartTotals.tsx importujemo komponentu CartTotalRow.tsx

191. Cart Items List
-u komponentu CartItemsList.tsx importujemo i kreiramo funkciju useAppSelector() iz foldera hooks
-vrijednost funkcije useAppSelector() pohranjujemo u varijablu const cartItems
-importujemo komponentu Card iz komponentu ui/card.tsx
-u roditelj div element dodajemo metodu cartItems.map()
-u funkciji map() destruktuiramo varijable const { cartID, title, price, image, amount, company, productColor } 
-dodajemo komponentu Card kao roditelj komponentu
-komponenti Card dodajemo prop key i className
-komponenti Card dodajemo Tailwind CSS klase
-u komponenti CartItemColumns.tsx kreiramo i eksportujemo cetiri funkcije FirstColumn, SecondColumn, ThirdColumn i FourthColumn
-u komponentu CartItemsList.tsx importujemo komponente iz komponente CartItemColumns.tsx
-u jsx-u dodajemo cetiri komponente 
-svakoj komponenti dodajemo nekoliko prop osim zadnjoj

192. First Column
-u komponenti CartItemColumns.tsx, funkciji FirstColumn() dodajemo parametre destruktuirane prop title i image
-destruktuiranim parametrima dodajemo tipove 
-u return izjavi kreiramo img element sa Tailwind CSS klasama

193. Second Column
-u komponenti CartItemColumns.tsx, funkciji SecondColumn() dodajemo parametre destruktuirane prop title, company i productColor
-destruktuiranim parametrima dodajemo tipove 
u return izjavi kreiramo HTML elemente sa Tailwind CSS klasama